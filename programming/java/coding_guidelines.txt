====== General Coding Guidelines ======

=====Coding Guidelines for "Efficient Code"=====

====Use Efficient Coding Techniques From The Start====
It's going to be an iterative process.  Start from the beginning.  Code is rarely ever "refactored" after the mistake is made.

====Allocate Memory up Front ====
Avoid allocating memory dynamically

====Reuse Object Instances====
If efficiency is important, try to avoid situations where the Java GC comes into play.

====Prefer Arrays over Java Collections====
Typically Arrays have lower overhead, are easier to iterate over and require less memory and programmatic footprint and are much faster than objects.

====Prefer 1D arrays over multi-dimensional arrays ====
Java creates a separate object for each 1D array.  An $N$ by $M$ array of primitives allocates $N+1$ objects.  An $I$ by $J$ by $K$ array allocates $I*J*+1$ objects.  Allocating objects is expensive, especially when garbage collecting is required to free memory to allocate the new objects.  

=====MultiThreaded Code=====
Multithreaded code is dangerous because Turing's computability proofs about stack machines to not apply; the computer may produce different results because the universe is a spiteful place.  Any mistakes in thready code, especially intermittent ones, will be painful to discover, analyze, and debug.

====Multi-threaded code check list====
  * Be paranoid
  * Know what threads will flow through the code you're working on.  If you're not sure, ask.
  * Know who in the area really understand the Java Thread model
  * Discuss what you are doing with someone who understands the Java Thread Model before you do it.
  * Record what you're up to in either the class-level javadoc (if it has scope limited to one class) or class-level and package-level javadoc (if it spans more than one class but fits in a package).  If it spans more than one package, god save us all.
  * Never subclass Thread.  Implement Runnable or Callable.
  * If an instance of a class must be thread safe, consider thread safety in every method within that class.  All access to the guarded references must be guarded.  With the same guard.
  * Avoid holding locks during long operations (e.g. I/O)
  * Do not allow a reference to this to escape during construction.
  * Favor using concurrent collections (e.g. ConcurrentHashMap, CopyOnWriteArrayLyst) over synchronized collections.
  * Discussions of guarding methods will be a lot shorter of you use the private final Object guard = new Object();
  * It is good practice to make all fields that do not need to be mutable, final.
  * If you need to guard collections, you need to guard iteration though those collections to avoid ConcurrentModificationExceptions.
  * Be aware when you're modifying thread safe code.  You'll need to follow the same rules.
  * Also, be paranoid.

====Designing Thread-safe classes====
  * When designing thread-safe classes, following good object-oriented principles, such as encapsulation and immutability, will make your life a lot easier.  If these principles need to be violated then be extra cautious and paranoid.
  * Thread-safe classes should encapsulate all synchronization.
  * Stateless objects and immutable objects are always thread-safe.
  * Where possible, use existing thread-safe objects.
  * Locking guarantees both visibility and atomicity, whereas volatile variables only guarantee visibility.

====Use of Synchronized====
Avoid using synchronized on methods.  Instead, surround methods in a synchronized block that is synchronized on a private final object.  For example:

<code java>
private final Object guard = new Object();

public void myMethod(){
  synchronized(guard){
    // do synchronized stuff.
  }
}
</code>
